---
description: 'Guidelines for XAML development in UWP applications'
applyTo: '**/*.xaml'
---

# XAML Development

## XAML Best Practices

- Use x:Bind over Binding for better performance and compile-time type checking.
- Specify binding Mode explicitly (OneWay, TwoWay, OneTime) for clarity.
- Use StaticResource for static resources like brushes and styles.
- Use ThemeResource for theme-aware resources that respond to theme changes.
- Name controls that are referenced in code-behind with x:Name.
- Use resource dictionaries for reusable styles and templates.
- Minimize XAML code-behind; prefer data binding and view models for logic.
- Keep XAML files focused and readable; extract complex templates into separate resource dictionaries.

## Data Binding

- Prefer x:Bind for better performance and compile-time validation.
- Use FallbackValue and TargetNullValue to handle missing or null data gracefully.
- Bind to view model properties rather than directly to models.
- Use converters for data transformations (in the Converters directory) or, preferably, x:Bind functions for better performance and compile-time validation.

## Localization

- All user-facing strings must be in resource files (.resw), never hardcoded in XAML or code-behind.
- The source language for resource files is US English (en-US). Add all new strings to the en-US resource file only. Other language resource files should be created by Crowdin.
- Use ReswPlus code generator to create strongly-typed properties and functions for localized strings.
- Access localized strings only from the view layer (XAML or code-behind), never from view models.
- Use string formatting functions generated by ReswPlus for parameterized strings.
- Bind localized strings in XAML using x:Bind to the generated resource properties.

## Accessibility

- Set AutomationProperties.Name if you use a custom ContentTemplate or nested elements in interactive elements (buttons, text boxes, etc.).
- Use AutomationProperties.LabeledBy to associate labels with input controls.
- Ensure proper keyboard navigation order with TabIndex when default tab order is insufficient.
- Support high contrast themes by using theme resources and testing with high contrast mode.
- Test with Narrator screen reader to ensure proper accessibility.
- Set AutomationProperties.AccessibilityView="Raw" for decorative elements that should be ignored by screen readers.
- Use semantic controls (e.g., Button, CheckBox) rather than generic controls with click handlers.

## Styling and Theming

- Define styles in resource dictionaries rather than inline.
- Use BasedOn for style inheritance to maintain consistency.
- Follow the application's design system for spacing, typography, and colors.
- Reuse existing resources, styles, and templates wherever possible.
- Use theme resources for colors to support light/dark theme switching.
- Test UI in both light and dark themes.

## Performance

- Use x:Load for conditionally visible UI to defer element creation and improve load times.
- Use incremental loading (ISupportIncrementalLoading) for large lists.
- Consider using ListView or GridView virtualizing for large data sets.
- Avoid deep visual trees; flatten where possible.
